# Quant Agent Evo 量化因子挖掘实验说明

## 目录
- [1. 项目概述](#1-项目概述)
- [2. 实验思路与方法论](#2-实验思路与方法论)
- [3. 主实验流程详解](#3-主实验流程详解)
- [4. 质量门控与一致性检验](#4-质量门控与一致性检验)
- [5. 独立回测框架](#5-独立回测框架)
- [6. 评价指标详解](#6-评价指标详解)
- [7. 实验配置与超参数](#7-实验配置与超参数)
- [8. 数据与回测设置](#8-数据与回测设置)
- [9. 实验结论与分析](#9-实验结论与分析)

---

## 1. 项目概述

### 1.1 项目目标

**Quant Agent Evo** 是一个基于大语言模型（LLM）驱动的量化因子自动挖掘系统。其核心目标是：

- **自动化因子发现**：利用 LLM 生成市场假设，并将假设转化为可计算的因子表达式
- **进化式优化**：通过变异（Mutation）和交叉（Crossover）操作，迭代优化因子质量
- **端到端回测验证**：基于 Qlib 框架进行因子回测，评估因子的预测能力和投资价值

### 1.2 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                   Quant Agent Evo 系统架构                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   用户输入（探索方向）                                              │
│         │                                                        │
│         ▼                                                        │
│   ┌──────────────┐                                               │
│   │   Planning   │ ──→ 生成 N 个并行探索方向                        │
│   └──────────────┘                                               │
│         │                                                        │
│         ▼                                                        │
│   ┌──────────────────────────────────────────────────────────┐  │
│   │              Evolution Controller                         │  │
│   │  ┌──────────┐  ┌──────────┐  ┌──────────┐               │  │
│   │  │ Original │→│ Mutation │→│ Crossover│→ 循环...        │  │
│   │  │   原始轮  │  │   变异轮  │  │   交叉轮  │               │  │
│   │  └──────────┘  └──────────┘  └──────────┘               │  │
│   └──────────────────────────────────────────────────────────┘  │
│         │                                                        │
│         ▼                                                        │
│   ┌──────────────────────────────────────────────────────────┐  │
│   │           AlphaAgentLoop（5 步循环 + 质量门控）             │  │
│   │                                                            │  │
│   │  1. factor_propose    → LLM 生成市场假设                   │  │
│   │  2. factor_construct  → LLM 生成因子表达式                  │  │
│   │        ↓ ┌──────────────────────────────────┐             │  │
│   │        └→│ 质量门控 (Quality Gate)           │             │  │
│   │          │ • 一致性检验 (Consistency Check)  │             │  │
│   │          │ • 复杂度检验 (Complexity Check)   │             │  │
│   │          │ • 冗余度检验 (Redundancy Check)   │             │  │
│   │          └──────────────────────────────────┘             │  │
│   │  3. factor_calculate  → 解析并计算因子值                    │  │
│   │  4. factor_backtest   → Qlib 回测                         │  │
│   │  5. feedback          → LLM 分析反馈 + 因子入库             │  │
│   └──────────────────────────────────────────────────────────┘  │
│         │                                                        │
│         ▼                                                        │
│   ┌──────────────┐                                               │
│   │  因子库 JSON  │ ──→ 所有有效因子的归档                         │
│   └──────────────┘                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 核心文件结构

| 文件/脚本 | 功能说明 |
|-----------|----------|
| `运行实验.sh` | 主实验入口脚本，激活环境并调用 `alphaagent mine` |
| `backtest_v2/run_backtest.py` | 独立回测工具，对因子库进行批量回测 |
| `run_config.yaml` | 主实验配置文件（规划、进化、回测参数） |
| `backtest_v2/config.yaml` | 独立回测配置文件 |
| `all_factors_library_*.json` | 因子库输出文件 |

---

## 2. 实验思路与方法论

### 2.1 核心方法：LLM 驱动的进化式因子挖掘

传统因子挖掘依赖人工经验和领域知识，效率低且难以规模化。Quant Agent Evo 采用创新的方法：

#### 2.1.1 假设驱动

```
用户输入（如"动量策略"）
        │
        ▼
   ┌─────────────────────────────────────────┐
   │  LLM 生成市场假设                         │
   │  例如：                                   │
   │  "过去N天收益率的动量效应在A股市场显著，    │
   │   短期动量可能反转而中期动量持续有效"       │
   └─────────────────────────────────────────┘
        │
        ▼
   ┌─────────────────────────────────────────┐
   │  LLM 将假设转化为因子表达式               │
   │  例如：                                   │
   │  ($close - Ref($close, 5)) / Ref($close, 5)  │
   │  Rank(Mean($close/Ref($close,1)-1, 20))      │
   └─────────────────────────────────────────┘
```

#### 2.1.2 进化式优化

借鉴遗传算法思想，通过 **变异** 和 **交叉** 操作优化因子：

```
             ┌─────────────────────────────────────────────┐
             │            进化流程                          │
             ├─────────────────────────────────────────────┤
             │                                             │
  Round 0    │   原始轮：N 个方向并行探索                     │
  (Original) │   → 生成 N 条初始轨迹                        │
             │                                             │
             │              │                              │
             │              ▼                              │
             │                                             │
  Round 1    │   变异轮：对原始轨迹进行"变异"                 │
  (Mutation) │   → 基于原始轨迹生成正交策略                  │
             │   → 避免重复探索相同路径                      │
             │                                             │
             │              │                              │
             │              ▼                              │
             │                                             │
  Round 2    │   交叉轮：选择 K 个父代组合                   │
  (Crossover)│   → 融合不同轨迹的优点                       │
             │   → 生成新的混合策略                         │
             │                                             │
             │              │                              │
             │              ▼                              │
             │                                             │
  Round 3+   │   继续 变异 → 交叉 → 变异 → ...              │
             │   直到达到最大轮数                           │
             │                                             │
             └─────────────────────────────────────────────┘
```

### 2.2 方法论优势

| 优势 | 说明 |
|------|------|
| **可解释性** | LLM 生成的因子带有假设说明，便于理解因子逻辑 |
| **多样性** | 进化机制确保因子多样化，避免局部最优 |
| **自动化** | 全流程自动化，减少人工干预 |
| **迭代优化** | 反馈机制让系统从失败中学习，持续改进 |

---

## 3. 主实验流程详解

### 3.1 启动命令

```bash
# 基本用法
./运行实验.sh "你的探索方向描述"

# 示例
./运行实验.sh "基于量价关系的短期反转因子"
./运行实验.sh "利用波动率和成交量构建市场情绪因子"
```

### 3.2 五步循环详解

每一轮探索包含 5 个核心步骤：

#### Step 1: factor_propose（假设生成）
- **输入**：探索方向 + 历史轨迹（trace）
- **过程**：调用 LLM 生成市场假设
- **输出**：结构化的假设描述（hypothesis）
- **核心模块**：`QuantAgentHypothesisGen`

```python
# 伪代码示例
hypothesis = llm.generate(
    prompt="""
    根据以下探索方向，生成一个可验证的市场假设：
    方向：{direction}
    历史经验：{trace.history}
    
    请描述：
    1. 假设的核心逻辑
    2. 预期的市场现象
    3. 可能的验证方法
    """
)
```

#### Step 2: factor_construct（因子构建）
- **输入**：市场假设
- **过程**：LLM 将假设转化为 2-3 个因子表达式
- **输出**：因子表达式列表
- **核心模块**：`QuantAgentHypothesis2FactorExpression`

```
# 因子表达式语法示例
$close                          # 收盘价
Ref($close, 5)                  # 5天前的收盘价
Mean($volume, 20)               # 20日均量
Rank($close / Ref($close, 1) - 1)  # 日收益率排名
Std($close / Ref($close, 1) - 1, 20)  # 20日收益率标准差
```

#### Step 3: factor_calculate（因子计算）
- **输入**：因子表达式
- **过程**：解析表达式并计算因子值
- **输出**：因子值矩阵（时间 × 股票）
- **核心模块**：`QlibFactorParser`

##### 3.1 计算流程概览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     因子计算流程                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   因子表达式输入                                                          │
│   例: "RANK(DELTA($close, 5) / TS_STD($close, 20))"                     │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  1. 表达式预处理 (expr_parser.py)                                  │  │
│   │     - 括号平衡检查                                                  │  │
│   │     - 无效运算符检查                                                │  │
│   │     - 一元负号预处理 (如 "* -$close" → "* (-1 * $close)")          │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  2. 表达式解析 (pyparsing 库)                                      │  │
│   │     - 构建 AST (抽象语法树)                                         │  │
│   │     - 运算符优先级: * / → + - → > < >= <= == != → && → ||          │  │
│   │     - 将中缀表达式转换为函数调用形式                                  │  │
│   │       例: "$close + $open" → "ADD($close, $open)"                  │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  3. 因子验证 (factor_regulator.py)                                 │  │
│   │     - 可解析性检查                                                  │  │
│   │     - 重复子树检测 (与已有因子库对比)                                 │  │
│   │     - 复杂度约束:                                                   │  │
│   │       · 符号长度 (SL) ≤ 300                                        │  │
│   │       · 基础特征数 (ER) ≤ 6                                         │  │
│   │       · 自由参数比例 < 50%                                          │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  4. 加载市场数据 (Qlib)                                            │  │
│   │     - 数据源: daily_pv.h5 (日线数据)                                │  │
│   │     - 包含: $open, $high, $low, $close, $volume                    │  │
│   │     - 索引: MultiIndex (instrument, datetime)                      │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  5. 递归计算因子值 (function_lib.py)                               │  │
│   │     - 变量替换: "$close" → "df['$close']"                          │  │
│   │     - 使用 eval() 执行解析后的表达式                                 │  │
│   │     - 所有函数自动处理 groupby('instrument') 分组                   │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  6. 结果输出与缓存                                                  │  │
│   │     - 输出: result.h5 (HDF5 格式)                                  │  │
│   │     - 索引: MultiIndex (instrument, datetime)                      │  │
│   │     - 数据类型: float64                                            │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

##### 3.2 表达式解析器实现

表达式解析器基于 **pyparsing** 库实现，支持完整的算术、比较、逻辑和条件表达式：

```python
# 核心解析逻辑 (expr_parser.py)

# 1. 定义基本元素
var = Combine(Optional("$") + Word(alphas, alphanums + "_"))  # 变量: $close, volume
number = Regex(r"[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?")   # 数字: 1.5, -3, 1e-8

# 2. 定义运算符优先级（从低到高）
expr = infixNotation(operand, [
    (mul_div,      2, LEFT,  parse_arith_op),      # * /
    (add_minus,    2, LEFT,  parse_arith_op),      # + -
    (comparison,   2, LEFT,  parse_comparison_op),  # > < >= <= == !=
    (logical_and,  2, LEFT,  parse_logical),        # && &
    (logical_or,   2, LEFT,  parse_logical),        # || |
    (conditional,  3, RIGHT, parse_conditional)     # ? :
])

# 3. 运算符转换为函数调用
# 例如: "$close + $open"  →  "ADD($close, $open)"
#       "$close > $open"  →  "GT($close, $open)"
#       "A ? B : C"       →  "WHERE(A, B, C)"
```

##### 3.3 支持的因子函数库

系统内置了丰富的因子计算函数（`function_lib.py`），分为以下几类：

**时间序列函数（TS_*）**- 按股票分组，沿时间轴计算

| 函数 | 说明 | 示例 |
|------|------|------|
| `DELTA(df, p)` | p 期差分 | `DELTA($close, 5)` 5日收盘价变化 |
| `DELAY(df, p)` | 延迟 p 期 | `DELAY($close, 1)` 昨日收盘价 |
| `TS_MEAN(df, p)` | p 期滚动均值 | `TS_MEAN($volume, 20)` 20日均量 |
| `TS_STD(df, p)` | p 期滚动标准差 | `TS_STD($close, 20)` 20日波动率 |
| `TS_MAX(df, p)` | p 期滚动最大值 | `TS_MAX($high, 10)` 10日最高价 |
| `TS_MIN(df, p)` | p 期滚动最小值 | `TS_MIN($low, 10)` 10日最低价 |
| `TS_RANK(df, p)` | p 期滚动排名 | `TS_RANK($close, 20)` 20日排名 |
| `TS_CORR(df1, df2, p)` | p 期滚动相关系数 | `TS_CORR($close, $volume, 20)` |
| `TS_SUM(df, p)` | p 期滚动累加 | `TS_SUM($volume, 5)` 5日成交量 |
| `TS_ARGMAX(df, p)` | 最大值位置 | `TS_ARGMAX($close, 20)` 最高点距今天数 |
| `TS_ARGMIN(df, p)` | 最小值位置 | `TS_ARGMIN($close, 20)` 最低点距今天数 |
| `TS_PCTCHANGE(df, p)` | p 期收益率 | `TS_PCTCHANGE($close, 5)` 5日收益率 |

**横截面函数（CS_*）**- 按日期分组，跨股票计算

| 函数 | 说明 | 示例 |
|------|------|------|
| `RANK(df)` | 横截面排名（百分比） | `RANK($close)` 收盘价排名 |
| `ZSCORE(df)` | 横截面标准化 | `ZSCORE($volume)` 成交量Z-Score |
| `MEAN(df)` | 横截面均值 | `MEAN($close)` 全市场平均价 |
| `STD(df)` | 横截面标准差 | `STD($close)` 全市场价格离散度 |
| `SCALE(df)` | 横截面缩放 | `SCALE($close)` 归一化 |

**数学函数**

| 函数 | 说明 | 示例 |
|------|------|------|
| `ABS(df)` | 绝对值 | `ABS(DELTA($close, 1))` |
| `LOG(df)` | 自然对数 | `LOG($volume)` |
| `SQRT(df)` | 平方根 | `SQRT($volume)` |
| `SIGN(df)` | 符号函数 | `SIGN(DELTA($close, 1))` |
| `POW(df, n)` | 幂运算 | `POW($close, 2)` |
| `EXP(df)` | 指数函数 | `EXP($close / 100)` |

**技术指标函数**

| 函数 | 说明 | 示例 |
|------|------|------|
| `SMA(df, m)` | 简单移动平均 | `SMA($close, 20)` |
| `EMA(df, p)` | 指数移动平均 | `EMA($close, 12)` |
| `WMA(df, p)` | 加权移动平均 | `WMA($close, 10)` |
| `MACD(price, s, l)` | MACD 指标 | `MACD($close, 12, 26)` |
| `RSI(price, p)` | 相对强弱指数 | `RSI($close, 14)` |
| `BB_UPPER/MIDDLE/LOWER` | 布林带 | `BB_UPPER($close, 20)` |
| `DECAYLINEAR(df, p)` | 线性衰减加权 | `DECAYLINEAR($close, 10)` |

**回归函数**

| 函数 | 说明 | 示例 |
|------|------|------|
| `REGBETA(y, x, p)` | 滚动回归系数 | `REGBETA($close, $volume, 20)` |
| `REGRESI(y, x, p)` | 滚动回归残差 | `REGRESI($close, MEAN($close), 20)` |

**逻辑与条件函数**

| 函数 | 说明 | 示例 |
|------|------|------|
| `GT(a, b)` | 大于 | `GT($close, $open)` |
| `LT(a, b)` | 小于 | `LT($close, DELAY($close, 1))` |
| `AND(a, b)` | 逻辑与 | `AND(GT($close, $open), GT($volume, 1e8))` |
| `OR(a, b)` | 逻辑或 | `OR(GT($close, $open), LT($low, $open))` |
| `WHERE(cond, t, f)` | 条件选择 | `WHERE(GT($close, $open), $high, $low)` |

##### 3.4 因子复杂度正则化

为防止因子过于复杂或与已有因子重复，系统实现了复杂度正则化（`FactorRegulator`）：

```
复杂度惩罚: R_g(f, h) = α₁·SL(f) + α₂·PC(f) + α₃·ER(f, h)

其中:
- SL(f): 符号长度 (Symbol Length) - 表达式字符数
- PC(f): 参数复杂度 (Parameter Complexity) - 自由参数比例
- ER(f, h): 特征冗余 (Expression Redundancy) - 基础特征数量
```

**验证规则**：

| 指标 | 阈值 | 说明 |
|------|------|------|
| 符号长度 (SL) | ≤ 300 | 表达式不能太长 |
| 基础特征数 (ER) | ≤ 6 | 最多使用 6 种原始特征 |
| 自由参数比例 | < 50% | 数值常量不能占比过高 |
| 重复子树大小 | ≤ 8 | 与已有因子的重复部分不能太大 |

##### 3.5 计算执行与缓存

因子计算的最终执行使用 Python 的 `eval()` 函数：

```python
# 计算模板 (template.jinja2)
def calculate_factor(expr: str, name: str):
    # 1. 加载数据
    df = pd.read_hdf('./daily_pv.h5', key='data')
    
    # 2. 符号替换
    expr = parse_symbol(expr, df.columns)   # TRUE → True, $close → close
    expr = parse_expression(expr)            # 解析为函数调用形式
    
    # 3. 变量替换
    for col in df.columns:
        expr = expr.replace(col[1:], f"df['{col}']")  # close → df['$close']
    
    # 4. 执行计算
    df[name] = eval(expr)  # 执行解析后的表达式
    result = df[name].astype(np.float64)
    
    # 5. 保存结果
    result.to_hdf('result.h5', key='data')
```

**缓存机制**：
- 计算结果保存为 HDF5 格式（`result.h5`）
- 工作空间路径：`/mnt/DATA/quantagent/AlphaAgent/RD-Agent_workspace/{UUID}/`
- 独立回测框架可通过缓存提取工具复用这些计算结果

#### Step 4: factor_backtest（因子回测）
- **输入**：计算好的因子值
- **过程**：基于 Qlib 进行机器学习回测
- **输出**：回测指标（IC、ICIR、收益率等）
- **核心模块**：`QlibFactorRunner`

```yaml
# 主程序回测配置 (conf.yaml)
训练集: 2016-01-01 ~ 2020-12-31  # 5年
验证集: 2021-01-01 ~ 2021-12-31  # 1年
测试集: 2022-01-01 ~ 2025-12-26  # 约4年

模型: LightGBM
策略: TopkDropoutStrategy (Top50, Drop5)
```

#### Step 5: feedback（反馈与入库）
- **输入**：回测结果 + 假设
- **过程**：LLM 分析结果，生成反馈
- **输出**：反馈报告 + 因子写入库
- **核心模块**：`QuantAgentQlibFactorHypothesisExperiment2Feedback`

```python
# 因子入库结构
factor_entry = {
    "factor_name": "momentum_5d",
    "factor_expression": "($close - Ref($close, 5)) / Ref($close, 5)",
    "hypothesis": "短期动量效应...",
    "direction": "动量策略",
    "evolution_phase": "original" | "mutation" | "crossover",
    "metrics": {
        "RankIC": 0.05,
        "RankICIR": 0.8,
        "annualized_return": 0.15,
        ...
    }
}
```

### 3.3 进化控制器

进化控制器（`EvolutionController`）管理整个进化流程：

```
┌─────────────────────────────────────────────────────────────┐
│                  Evolution Controller                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  TrajectoryPool（轨迹池）                                     │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Trajectory 1: direction=0, phase=original, ic=0.03  │   │
│  │ Trajectory 2: direction=1, phase=original, ic=0.05  │   │
│  │ Trajectory 3: direction=0, phase=mutation, ic=0.04  │   │
│  │ Trajectory 4: parents=[1,2], phase=crossover, ic=0.06│   │
│  │ ...                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
│  任务调度逻辑                                                  │
│  ├─ Original: 为每个 planning 方向创建初始任务                  │
│  ├─ Mutation: 对每条已有轨迹生成变异任务                        │
│  └─ Crossover: 选择 K 个父代组合，生成交叉任务                  │
│                                                              │
│  父代选择策略                                                  │
│  ├─ best: 优先选择表现最好的轨迹                               │
│  ├─ weighted: 性能加权采样（差的更可能被选中，鼓励探索）          │
│  └─ random: 随机选择                                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```
交叉轮评估器的评估机制
1. 可见的评价指标
交叉轮评估器可以看到每个轨迹的 7 个指标：
指标	说明	用途
IC	信息系数	因子与收益的相关性
ICIR	IC 信息比率	IC 的稳定性
RankIC	排名 IC	更稳健的因子相关性指标
RankICIR	排名 IC 信息比率	RankIC 的稳定性
annualized_return	年化超额收益率	策略收益能力
information_ratio	信息比率	风险调整后收益
max_drawdown	最大回撤	策略风险
2. 主要评估指标
当前使用 RankIC 作为主要评估指标（get_primary_metric() 方法）：
trajectory.pyLines 90-92
def get_primary_metric(self) -> Optional[float]:    """Get the primary metric (RankIC) for comparison."""    return self.backtest_metrics.get("RankIC")
3. 评估用于哪些决策
决策环节	使用方式
父代选择	根据 parent_selection_strategy 使用 get_primary_metric() (RankIC) 排序或加权
组合评分	select_crossover_pairs 中根据平均 RankIC 评估组合质量
多样性偏好	结合 direction_id 多样性 + phase 多样性 + 平均性能综合打分
4. LLM 可见的轨迹信息
在生成交叉提示词时，LLM 可以看到：
### Parent 1: Original Round**Direction ID**: 0**Hypothesis**: 价量因子挖掘...**Factors**:  - ROC60_Factor: RANK(TS_PCTCHANGE($close, 60))...**Metrics**:  - IC: 0.0053  - ICIR: 0.0418  - RankIC: 0.0220  - RankICIR: 0.1789  - annualized_return: 0.068  - information_ratio: 1.12  - max_drawdown: -0.05**Feedback**: The results show...
5. 评估流程图
┌─────────────────────────────────────────────────────────────────┐│                    交叉轮评估流程                                │├─────────────────────────────────────────────────────────────────┤│                                                                  ││  1. 候选轨迹池 (来自前几轮)                                       ││     ├── 轨迹A: RankIC=0.22, direction=0, phase=original          ││     ├── 轨迹B: RankIC=0.18, direction=1, phase=original          ││     ├── 轨迹C: RankIC=0.25, direction=0, phase=mutation          ││     └── 轨迹D: RankIC=0.15, direction=1, phase=mutation          ││                                                                  ││  2. 根据 parent_selection_strategy 筛选                          ││     ├── best: 按 RankIC 降序取 Top-N                             ││     ├── weighted: 高 RankIC 权重大                                ││     ├── weighted_inverse: 低 RankIC 权重大（探索）                 ││     └── top_percent_plus_random: 前30%必选 + 随机                 ││                                                                  ││  3. 生成组合并评分                                                ││     ├── 组合1: [A, C] → score = diversity + avg_metric            ││     ├── 组合2: [A, D] → score = ...                               ││     └── ...                                                       ││                                                                  ││  4. 选择 Top-N 组合作为交叉父代                                    ││                                                                  │└─────────────────────────────────────────────────────────────────┘
---

## 4. 质量门控与一致性检验

### 4.1 模块概述

质量门控（Quality Gate）是因子生成流程中的重要环节，在因子构建（`factor_construct`）完成后、代码计算（`factor_calculate`）之前执行。其核心目的是确保生成的因子在语义和技术层面都符合质量标准。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     因子质量门控流程                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   factor_construct 输出                                                  │
│   ├── 假设 (Hypothesis)                                                  │
│   ├── 因子描述 (Description)                                             │
│   ├── 数学公式 (Formulation)                                             │
│   └── 符号表达式 (Expression)                                            │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │              质量门控 (Quality Gate)                               │  │
│   │                                                                    │  │
│   │  ┌────────────────────────────────────────────────────────────┐  │  │
│   │  │  1. 一致性检验 (Consistency Check)                          │  │  │
│   │  │     - 假设 → 描述 一致性                                     │  │  │
│   │  │     - 描述 → 公式 一致性                                     │  │  │
│   │  │     - 公式 → 表达式 一致性                                   │  │  │
│   │  │     - 如发现不一致，LLM 尝试修正表达式                        │  │  │
│   │  │     ⚙️ 配置: quality_gate.consistency_enabled                │  │  │
│   │  └────────────────────────────────────────────────────────────┘  │  │
│   │                              │                                    │  │
│   │                              ▼                                    │  │
│   │  ┌────────────────────────────────────────────────────────────┐  │  │
│   │  │  2. 复杂度检验 (Complexity Check)                           │  │  │
│   │  │     - 符号长度 (SL): 表达式字符数 ≤ 250                      │  │  │
│   │  │     - 基础特征数 (ER): 原始特征种类 ≤ 6                      │  │  │
│   │  │     - 自由参数比例: 数值常量占比 < 50%                       │  │  │
│   │  │     ⚙️ 配置: quality_gate.complexity_enabled                 │  │  │
│   │  └────────────────────────────────────────────────────────────┘  │  │
│   │                              │                                    │  │
│   │                              ▼                                    │  │
│   │  ┌────────────────────────────────────────────────────────────┐  │  │
│   │  │  3. 冗余度检验 (Redundancy Check)                           │  │  │
│   │  │     - 与因子库进行 AST 子树匹配                              │  │  │
│   │  │     - 重复子树大小 ≤ 阈值                                    │  │  │
│   │  │     ⚙️ 配置: quality_gate.redundancy_enabled                 │  │  │
│   │  └────────────────────────────────────────────────────────────┘  │  │
│   │                                                                    │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│         │                                                                │
│         ▼                                                                │
│   ┌──────────────────────────────────────────────────────────────────┐  │
│   │  通过质量门控 → factor_calculate (代码生成与计算)                  │  │
│   │  未通过 → 标记因子，记录反馈，继续后续流程                          │  │
│   └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 一致性检验 (Consistency Check)

一致性检验是质量门控的核心模块，使用 LLM 验证因子生成各阶段之间的语义逻辑一致性。

#### 4.2.1 检验内容

| 检验环节 | 检验内容 | 示例问题 |
|----------|----------|----------|
| 假设→描述 | 因子描述是否正确反映市场假设的核心逻辑 | 假设说"动量反转"，描述却实现了"趋势跟随" |
| 描述→公式 | 数学公式是否正确表达了描述中的计算逻辑 | 描述说"20日移动平均"，公式写成"10日" |
| 公式→表达式 | 符号表达式是否正确实现了数学公式 | 公式用除法，表达式用减法 |

#### 4.2.2 严重程度分级

```python
# 一致性问题严重程度
severity_levels = {
    "none": "无问题，因子完全一致",
    "minor": "轻微不一致，如窗口参数略有差异（10天vs15天），不影响因子核心含义",
    "major": "显著不一致，可能影响因子的经济学解释",
    "critical": "严重不一致，表达式与假设完全矛盾"
}
```

#### 4.2.3 修正机制

当检测到不一致时，系统会：
1. **尝试修正表达式**：LLM 根据假设和描述重新生成表达式
2. **多次尝试**：默认最多尝试 3 次修正（`max_correction_attempts: 3`）
3. **容错处理**：如果修正失败，标记因子但不阻断流程（除非开启严格模式）

```python
# 修正流程伪代码
for attempt in range(max_correction_attempts):
    result = check_consistency(hypothesis, description, expression)
    if result.is_consistent:
        return expression  # 通过
    if result.corrected_expression:
        expression = result.corrected_expression  # 应用修正
    else:
        break  # 无法修正

# 根据严重程度决定是否继续
if result.severity in ["none", "minor"]:
    proceed_to_backtest = True
elif strict_mode:
    proceed_to_backtest = False
```

### 4.3 复杂度检验 (Complexity Check)

复杂度检验确保因子表达式不会过于复杂，避免过拟合风险。

| 指标 | 阈值 | 说明 | 配置项 |
|------|------|------|--------|
| 符号长度 (SL) | ≤ 250 | 表达式总字符数，过长表示过于复杂 | `factor.complexity.symbol_length_threshold` |
| 基础特征数 (ER) | ≤ 6 | 使用的原始特征种类（$close, $open 等） | `factor.complexity.base_features_threshold` |
| 自由参数比例 | < 50% | 数值常量占总节点数的比例，过高表示过度参数化 | `factor.complexity.free_args_ratio_threshold` |

### 4.4 冗余度检验 (Redundancy Check)

冗余度检验通过 AST（抽象语法树）分析，检测因子表达式是否与已有因子重复。

```
示例：
现有因子: RANK(TS_MEAN($close, 20))
新因子:   RANK(TS_MEAN($close, 20) / TS_STD($close, 20))
                ^^^^^^^^^^^^^^^^^^^^
                重复子树大小 = 3 (RANK, TS_MEAN, $close)

如果重复子树大小 > duplication_threshold，则认为因子冗余
```

### 4.5 配置说明

在 `run_config.yaml` 中配置质量门控：

```yaml
# ============================================================
# QUALITY GATE CONFIGURATION
# 质量门控配置
# ============================================================
quality_gate:
  # 是否启用一致性检验（默认关闭，会增加 LLM 调用成本）
  consistency_enabled: false
  
  # 是否启用复杂度检验（默认开启）
  complexity_enabled: true
  
  # 是否启用冗余度检验（默认开启）
  redundancy_enabled: true

# 因子复杂度约束参数
factor:
  complexity:
    symbol_length_threshold: 250    # 符号长度阈值
    base_features_threshold: 6      # 基础特征数阈值
    free_args_ratio_threshold: 0.5  # 自由参数比例阈值
  
  duplication:
    enabled: true                   # 启用重复性检查
    threshold: 5                    # 重复子树大小阈值
    factor_zoo_path: null           # 因子库路径（null 使用默认）
```

### 4.6 核心代码模块

| 模块 | 路径 | 功能 |
|------|------|------|
| `FactorQualityGate` | `scenarios/qlib/regulator/consistency_checker.py` | 质量门控主类，整合三种检验 |
| `FactorConsistencyChecker` | `scenarios/qlib/regulator/consistency_checker.py` | LLM 一致性检验 |
| `ComplexityChecker` | `scenarios/qlib/regulator/consistency_checker.py` | 复杂度检验 |
| `RedundancyChecker` | `scenarios/qlib/regulator/consistency_checker.py` | 冗余度检验（调用 FactorRegulator） |
| `FactorRegulator` | `scenarios/qlib/regulator/factor_regulator.py` | AST 分析与冗余检测核心 |
| `factor_ast.py` | `components/coder/factor_coder/factor_ast.py` | AST 解析与复杂度计算函数 |
| 提示词配置 | `scenarios/qlib/regulator/consistency_prompts.yaml` | LLM 一致性检验提示词 |
| 集成位置 | `components/workflow/alphaagent_loop.py` | 在 `factor_construct` 步骤中调用 |

---

### 4.7 复杂度计算技术详解

复杂度检验基于 **AST（抽象语法树）** 分析，实现了论文中的复杂度正则化公式：

$$R_g(f, h) = \alpha_1 \cdot SL(f) + \alpha_2 \cdot PC(f) + \alpha_3 \cdot ER(f, h)$$

#### 4.7.1 AST 节点类型

因子表达式首先被解析为以下节点类型的 AST：

```python
# 节点类型定义 (factor_ast.py)
@dataclass
class VarNode(Node):      # 变量节点: $close, $volume 等
    name: str

@dataclass  
class NumberNode(Node):   # 数值常量节点: 14, 1e-8, 0.5 等
    value: float

@dataclass
class FunctionNode(Node): # 函数调用节点: TS_MEAN($close, 20)
    name: str
    args: List[Node]

@dataclass
class BinaryOpNode(Node): # 二元运算符节点: $close + $open
    op: str
    left: Node
    right: Node

@dataclass
class ConditionalNode(Node): # 条件表达式节点: A ? B : C
    condition: Node
    true_expr: Node
    false_expr: Node

@dataclass
class UnaryOpNode(Node):  # 一元运算符节点: -$close
    op: str
    operand: Node
```

#### 4.7.2 复杂度指标计算函数

**1. 符号长度 (SL - Symbol Length)**

```python
def calculate_symbol_length(expr: str) -> int:
    """
    计算表达式的符号长度（字符数）
    过长的表达式通常意味着过于复杂，容易过拟合
    """
    return len(expr.strip())

# 示例
expr = "POW(REGBETA(DELTA(LOG($close), 1), SEQUENCE(10), 10), 2)"
# SL = 58
```

**2. 基础特征数 (ER - Base Features)**

```python
def count_base_features(expr: str) -> int:
    """
    统计表达式中使用的原始特征种类（以$开头的变量）
    使用过多原始特征可能导致过拟合
    """
    tree = parse_expression(expr)
    base_features = set()  # 去重集合
    collect_base_features(tree, base_features)
    return len(base_features)

def collect_base_features(node: Node, base_features: set) -> None:
    """递归收集所有基础特征"""
    if isinstance(node, VarNode):
        if node.name.startswith('$'):  # 只收集原始特征
            base_features.add(node.name)
    elif isinstance(node, FunctionNode):
        for arg in node.args:
            collect_base_features(arg, base_features)
    elif isinstance(node, BinaryOpNode):
        collect_base_features(node.left, base_features)
        collect_base_features(node.right, base_features)
    # ... 其他节点类型递归处理

# 示例
expr = "($close - $open) / ($high - $low) * $volume"
# 基础特征: {$close, $open, $high, $low, $volume}
# ER = 5
```

**3. 自由参数数 (Free Args - 数值常量)**

```python
def count_free_args(expr: str) -> int:
    """
    统计表达式中的数值常量数量
    过多的数值常量意味着过度参数化
    """
    tree = parse_expression(expr)
    return count_number_nodes(tree)

def count_number_nodes(node: Node) -> int:
    """递归统计 NumberNode 数量"""
    if isinstance(node, NumberNode):
        return 1
    elif isinstance(node, VarNode):
        return 0
    elif isinstance(node, FunctionNode):
        return sum(count_number_nodes(arg) for arg in node.args)
    elif isinstance(node, BinaryOpNode):
        return count_number_nodes(node.left) + count_number_nodes(node.right)
    return 0

# 示例
expr = "TS_MEAN($close, 20) / TS_STD($close, 10) + 1e-8"
# 数值常量: 20, 10, 1e-8
# Free Args = 3
```

**4. 总节点数 (All Nodes)**

```python
def count_all_nodes(expr: str) -> int:
    """统计 AST 中的总节点数"""
    tree = parse_expression(expr)
    return count_nodes(tree)

def count_nodes(node: Node) -> int:
    """递归统计所有节点"""
    if isinstance(node, (NumberNode, VarNode)):
        return 1
    elif isinstance(node, FunctionNode):
        return 1 + sum(count_nodes(arg) for arg in node.args)
    elif isinstance(node, BinaryOpNode):
        return 1 + count_nodes(node.left) + count_nodes(node.right)
    elif isinstance(node, ConditionalNode):
        return 1 + count_nodes(node.condition) + \
               count_nodes(node.true_expr) + count_nodes(node.false_expr)
    return 0
```

#### 4.7.3 复杂度检验判定逻辑

```python
class ComplexityChecker:
    def check(self, expression: str) -> Tuple[bool, str]:
        # 1. 符号长度检查
        symbol_length = calculate_symbol_length(expression)
        if symbol_length > 250:  # 默认阈值
            return False, f"SL Check Failed: {symbol_length} > 250"
        
        # 2. 基础特征检查
        num_base_features = count_base_features(expression)
        if num_base_features > 6:  # 默认阈值
            return False, f"ER Check Failed: {num_base_features} > 6"
        
        # 3. 自由参数比例检查
        num_free_args = count_free_args(expression)
        num_all_nodes = count_all_nodes(expression)
        if num_all_nodes > 0:
            free_args_ratio = num_free_args / num_all_nodes
            if free_args_ratio > 0.5:  # 默认阈值 50%
                return False, f"Free Args Ratio Failed: {free_args_ratio:.2%} > 50%"
        
        return True, "Complexity check passed"
```

---

### 4.8 冗余度检验技术详解

冗余度检验通过 **AST 子树匹配** 来判断新因子是否与已有因子过于相似。

#### 4.8.1 核心算法：最大公共子树匹配

```python
def find_largest_common_subtree(root1: Node, root2: Node) -> Optional[SubtreeMatch]:
    """
    找到两棵 AST 树之间最大的公共子树
    
    算法流程:
    1. 获取两棵树的所有子树
    2. 对每对子树进行相等性比较
    3. 找到最大的匹配子树
    """
    
    def get_all_subtrees(root: Node) -> List[Node]:
        """递归获取所有子树"""
        result = [root]
        if isinstance(root, FunctionNode):
            for arg in root.args:
                result.extend(get_all_subtrees(arg))
        elif isinstance(root, BinaryOpNode):
            result.extend(get_all_subtrees(root.left))
            result.extend(get_all_subtrees(root.right))
        elif isinstance(root, ConditionalNode):
            result.extend(get_all_subtrees(root.condition))
            result.extend(get_all_subtrees(root.true_expr))
            result.extend(get_all_subtrees(root.false_expr))
        return result
    
    def is_commutative_op(op: str) -> bool:
        """判断是否为可交换操作符"""
        return op in {'+', '*', '==', '!=', '&', '&&', '|', '||'}
    
    def are_subtrees_equal(node1: Node, node2: Node) -> bool:
        """
        递归比较两个子树是否相等
        对于可交换操作符，考虑两种顺序
        """
        # 节点类型必须相同
        if type(node1) != type(node2):
            return False
        
        if isinstance(node1, NumberNode):
            return node1.value == node2.value
        elif isinstance(node1, VarNode):
            return node1.name == node2.name
        elif isinstance(node1, FunctionNode):
            if node1.name != node2.name or len(node1.args) != len(node2.args):
                return False
            return all(are_subtrees_equal(a1, a2) 
                      for a1, a2 in zip(node1.args, node2.args))
        elif isinstance(node1, BinaryOpNode):
            if node1.op != node2.op:
                return False
            # 对于可交换操作符，尝试两种顺序
            if is_commutative_op(node1.op):
                return (are_subtrees_equal(node1.left, node2.left) and 
                        are_subtrees_equal(node1.right, node2.right)) or \
                       (are_subtrees_equal(node1.left, node2.right) and 
                        are_subtrees_equal(node1.right, node2.left))
            else:
                return are_subtrees_equal(node1.left, node2.left) and \
                       are_subtrees_equal(node1.right, node2.right)
        return False
    
    # 获取所有子树
    subtrees1 = get_all_subtrees(root1)
    subtrees2 = get_all_subtrees(root2)
    
    # 找到最大的公共子树
    max_match = None
    max_size = 0
    
    for st1 in subtrees1:
        size1 = get_subtree_size(st1)
        if size1 <= max_size:
            continue
        for st2 in subtrees2:
            if are_subtrees_equal(st1, st2):
                max_size = size1
                max_match = SubtreeMatch(st1, st2, size1)
    
    return max_match
```

#### 4.8.2 与因子库匹配

```python
def match_alphazoo(prop_expr: str, factor_df: pd.DataFrame) -> Tuple[int, Node, str]:
    """
    将新因子表达式与整个因子库进行匹配
    
    Returns:
        max_size: 最大重复子树大小
        matched_subtree: 匹配的子树
        matched_alpha: 匹配的因子表达式
    """
    max_size = 0
    matched_subtree = None
    matched_alpha = None
    
    for index, (name, alpha_expr) in factor_df.iterrows():
        try:
            match = compare_expressions(prop_expr, alpha_expr)
            if match is not None and match.size > max_size:
                max_size = match.size
                matched_subtree = match.root1
                matched_alpha = alpha_expr
        except Exception as e:
            continue
    
    return max_size, matched_subtree, matched_alpha
```

#### 4.8.3 冗余度判定示例

```
现有因子库中的因子:
  Factor A: RANK(TS_MEAN($close, 20))
  Factor B: TS_STD($close, 10) / TS_MEAN($volume, 5)

新因子: RANK(TS_MEAN($close, 20) / TS_STD($close, 20))

匹配过程:
1. 与 Factor A 比较:
   - 找到公共子树: RANK(TS_MEAN($close, 20))
   - 子树大小: 4 个节点 (RANK, TS_MEAN, $close, 20)
   
2. 与 Factor B 比较:
   - 找到公共子树: $close
   - 子树大小: 1 个节点

结果: 
  duplicated_subtree_size = 4
  matched_alpha = "RANK(TS_MEAN($close, 20))"

判定:
  如果 threshold = 5: 4 ≤ 5 → 通过 ✅
  如果 threshold = 3: 4 > 3 → 拒绝 ❌ (因子过于冗余)
```

---

### 4.9 因子合格判定完整流程

```python
class FactorRegulator:
    def is_expression_acceptable(self, eval_dict: dict) -> bool:
        """
        综合判定因子是否合格
        实现论文中的复杂度正则化: R_g(f, h) = α₁·SL(f) + α₂·PC(f) + α₃·ER(f, h)
        """
        # 条件 1: 冗余度检查 - 重复子树不能太大
        cond1 = eval_dict['duplicated_subtree_size'] <= self.duplication_threshold  # 默认 5-8
        
        # 获取复杂度指标
        num_free_args = eval_dict['num_free_args']       # 数值常量数
        num_unique_vars = eval_dict['num_unique_vars']   # 唯一变量数
        num_all_nodes = eval_dict['num_all_nodes']       # 总节点数
        symbol_length = eval_dict['symbol_length']       # 符号长度
        num_base_features = eval_dict['num_base_features']  # 基础特征数
        
        # 计算比例
        free_args_ratio = num_free_args / num_all_nodes
        unique_vars_ratio = num_unique_vars / num_all_nodes
        
        # 条件 2: 自由参数比例不能太高
        # 使用 -log(1-x) 变换，x < 0.5 时阈值为 0.693
        cond2 = -np.log(1 - free_args_ratio) < 0.693  # 即 ratio < 50%
        
        # 条件 3: 唯一变量比例不能太高
        cond3 = -np.log(1 - unique_vars_ratio) < 0.693  # 即 ratio < 50%
        
        # 条件 4: 符号长度 (SL) 不能太长
        cond4 = symbol_length <= self.symbol_length_threshold  # 默认 300
        
        # 条件 5: 基础特征数 (ER) 不能太多
        cond5 = num_base_features <= self.base_features_threshold  # 默认 6
        
        # 所有条件都满足才合格
        return cond1 and cond2 and cond3 and cond4 and cond5
```

#### 4.9.1 判定结果日志示例

```
Evaluated expr: POW(REGBETA(DELTA(LOG($close), 1), SEQUENCE(10), 10), 2) * (($high - $low) / (...))

评估结果:
  Duplicated Size: 3          # 与因子库最大公共子树 ≤ 5 ✅
  Duplicated Subtree: ($high - $low)
  # Free Args: 4              # 数值常量 (10, 10, 2, 1e-8)
  # Unique Vars: 4            # 唯一变量 ($close, $high, $low)
  # All Nodes: 18
  Symbol Length (SL): 156     # < 300 ✅
  # Base Features (ER): 3     # < 6 ✅
  Free Args Ratio: 22.2%      # < 50% ✅
  Unique Vars Ratio: 22.2%    # < 50% ✅

综合判定: 因子合格 ✅ → 进入回测阶段
```

#### 4.9.2 判定失败示例

```
Evaluated expr: TS_MEAN($close, 5) + TS_MEAN($open, 10) + TS_MEAN($high, 15) + 
                TS_MEAN($low, 20) + TS_MEAN($volume, 25) + TS_MEAN($amount, 30) + 
                TS_MEAN($turnover, 35)

评估结果:
  Duplicated Size: 2          # ≤ 5 ✅
  # Free Args: 7              # 数值常量 (5,10,15,20,25,30,35)
  # Unique Vars: 7            # 唯一变量
  # All Nodes: 22
  Symbol Length (SL): 189     # < 300 ✅
  # Base Features (ER): 7     # > 6 ❌ 使用了过多原始特征
  Free Args Ratio: 31.8%      # < 50% ✅
  Unique Vars Ratio: 31.8%    # < 50% ✅

综合判定: 因子不合格 ❌
原因: Base Features (ER) Check Failed: 7 > 6. Using too many raw features.
```

### 4.10 使用建议

1. **开发阶段**：建议开启所有三种检验，帮助发现问题
2. **生产阶段**：可关闭一致性检验以节省 LLM 成本，保留复杂度和冗余度检验
3. **严格模式**：如需确保因子质量，可开启 `strict_mode`，不一致因子将被完全拒绝

```yaml
# 开发配置（全开）
quality_gate:
  consistency_enabled: true
  complexity_enabled: true
  redundancy_enabled: true

# 生产配置（节省成本）
quality_gate:
  consistency_enabled: false
  complexity_enabled: true
  redundancy_enabled: true
```

---

## 5. 独立回测框架

### 5.1 设计目的

主实验过程中的回测（`factor_backtest`）用于快速评估单个因子。而独立回测框架（`backtest_v2`）用于：

1. **批量评估**：对整个因子库进行统一回测
2. **长周期验证**：使用更长的测试期（2022-2025）验证因子稳定性
3. **组合效果**：评估多因子组合的整体表现
4. **对照实验**：与 Qlib 官方因子库（Alpha158）进行对比

### 4.2 回测配置

```yaml
# backtest_v2/config.yaml 关键配置

数据配置:
  数据源: /home/tjxy/.qlib/qlib_data/cn_data
  市场: csi300 (沪深300成分股)
  数据范围: 2016-01-01 ~ 2025-12-26

数据集划分:
  训练集: 2016-01-01 ~ 2020-12-31  # 模型学习历史规律
  验证集: 2021-01-01 ~ 2021-12-31  # 模型调参
  测试集: 2022-01-01 ~ 2025-12-26  # 样本外验证（最终评估）

模型配置:
  模型类型: LightGBM
  学习率: 0.1
  最大深度: 8
  叶子节点数: 210
  早停轮数: 50
  最大迭代: 500

回测策略:
  策略: TopkDropoutStrategy
  - topk: 50      # 持有评分最高的50只股票
  - n_drop: 5     # 每次调仓剔除评分最低的5只
  
交易成本:
  买入: 0.05%
  卖出: 0.15%
  最低: 5元
```

### 4.3 使用方式

```bash
# 单个因子库回测
python backtest_v2/run_backtest.py \
    -c backtest_v2/config.yaml \
    --factor-source custom \
    --factor-json /path/to/factors.json

# 与 Alpha158 对比
python backtest_v2/run_backtest.py \
    -c backtest_v2/config.yaml \
    --factor-source alpha158_20

# 批量回测
./批量回测.sh
```

### 4.4 两套回测的区别

| 特性 | 主程序内部回测 | 独立回测框架 |
|------|---------------|--------------|
| 用途 | 快速评估单因子 | 批量评估因子库 |
| 回测期 | 2021年（验证集） | 2022-2025（测试集） |
| 因子数 | 2-3个/轮 | 整个因子库 |
| 缓存 | 自动缓存到 workspace | 独立缓存目录 |
| 输出 | 写入因子库 JSON | 独立指标 JSON |

---

## 6. 评价指标详解

### 6.1 重要说明：收益指标均为超额收益

⚠️ **注意**：回测框架输出的收益类指标（`annualized_return`、`max_drawdown` 等）**均为超额收益**，即相对于基准（沪深300指数）的超额表现，而非绝对收益。

**计算公式**：
```python
超额收益 = 组合收益 - 基准收益 - 交易成本
excess_return = portfolio_return - bench_return - cost
```

所有风险分析指标（年化收益、最大回撤、信息比率等）均基于此超额收益序列计算。

### 6.2 预测能力指标

#### IC (Information Coefficient)
```
定义: 因子值与未来收益的 Pearson 相关系数
范围: [-1, 1]
解读:
  IC > 0.03: 因子有一定预测能力
  IC > 0.05: 因子预测能力较强
  IC > 0.10: 因子预测能力很强（罕见）
  
计算公式:
  IC_t = Corr(Factor_t, Return_{t+1})
  IC = Mean(IC_t)  # 所有时间的平均
```

#### ICIR (IC Information Ratio)
```
定义: IC 的均值与标准差之比
公式: ICIR = Mean(IC) / Std(IC)
解读:
  ICIR > 0.5: 因子预测能力稳定
  ICIR > 1.0: 因子预测能力非常稳定
  
意义: IC 高但不稳定的因子可能不如 IC 适中但稳定的因子
```

#### Rank IC
```
定义: 因子排名与收益排名的 Spearman 相关系数
优势: 对异常值更鲁棒，更适合实际投资场景
```

#### Rank ICIR
```
定义: Rank IC 的均值与标准差之比
公式: RankICIR = Mean(RankIC) / Std(RankIC)
```

### 6.3 收益指标（均为超额收益）

#### 超额年化收益率 (Annualized Return)
```
定义: 策略相对于基准的年化超额收益
公式: Ann_Excess_Return = (1 + Total_Excess_Return)^(252/Trading_Days) - 1
示例:
  0.18 (18%) 表示策略每年跑赢基准 18%
  
注意: 此指标已扣除交易成本
```

#### 信息比率 (Information Ratio)
```
定义: 超额收益与跟踪误差之比
公式: IR = Mean(Excess_Return) / Std(Excess_Return) × √252
解读:
  IR > 1.0: 策略显著跑赢基准
  IR > 2.0: 策略表现优异
  
意义: 衡量每承担1单位跟踪误差风险，可获得多少超额收益
```

#### 超额最大回撤 (Max Drawdown)
```
定义: 超额收益曲线从历史最高点到最低点的最大跌幅
公式: MDD = min((Excess_Cumulative_t - Excess_Peak) / Excess_Peak)
示例:
  -0.09 (-9%) 表示超额收益最大从高点下跌 9%
  
注意: 这是相对于基准的回撤，不是组合绝对回撤
```

#### 卡尔玛比率 (Calmar Ratio)
```
定义: 超额年化收益与超额最大回撤的比值
公式: Calmar = Ann_Excess_Return / |MDD|
解读:
  Calmar > 1.0: 收益风险比较好
  Calmar > 2.0: 收益风险比优秀
```

### 6.4 指标解读示例

以实际回测结果为例（`QA_phase_mutation` 因子库）：

```json
{
  "IC": 0.1277,                    // 非常强的预测能力
  "ICIR": 0.8738,                  // 预测能力稳定
  "Rank IC": 0.1242,               // 排名预测能力强
  "Rank ICIR": 0.8566,             // 排名预测稳定
  "annualized_return": 0.1827,     // 超额年化收益 18.27%
  "information_ratio": 2.2588,     // 信息比率 2.26
  "max_drawdown": -0.0894,         // 超额最大回撤 8.94%
  "calmar_ratio": 2.0447           // 收益风险比 2.04
}
```

**综合评价**：
- 该因子库在 2022-2025 测试期表现优异
- IC > 0.12 表明因子组合有很强的收益预测能力
- **超额年化收益 18.27%**：策略每年平均跑赢沪深300指数 18.27%（已扣除交易成本）
- **信息比率 2.26**：每承担 1% 的跟踪误差，可获得 2.26% 的超额收益（IR > 2 通常被认为优秀）
- **超额最大回撤 8.94%**：相对于基准的最大下跌幅度控制在 9% 以内
- **卡尔玛比率 2.04**：超额收益是最大回撤的 2 倍，风险收益比良好

### 6.5 与基准对比总结

| 指标类型 | 具体指标 | 基准对比方式 |
|----------|----------|--------------|
| 预测能力 | IC, ICIR, Rank IC, Rank ICIR | 直接计算因子与收益的相关性 |
| 收益指标 | annualized_return | **超额**年化 = 组合年化 - 基准年化 - 成本 |
| 风险指标 | max_drawdown | **超额**收益曲线的最大回撤 |
| 综合指标 | information_ratio, calmar_ratio | 基于超额收益计算 |

**基准设置**：
```yaml
benchmark: SH000300  # 沪深300指数
market: csi300       # 沪深300成分股
```

---

## 7. 实验配置与超参数

### 7.1 核心超参数

#### 规划阶段 (Planning)
```yaml
planning:
  num_directions: 10    # 并行探索方向数
                        # 越大 → 初始探索越广，但资源消耗越大
                        # 建议范围: 5-15
```

#### 进化阶段 (Evolution)
```yaml
evolution:
  max_rounds: 5         # 最大进化轮数
                        # 越大 → 探索越深入，但耗时越长
                        # 建议范围: 3-7
  
  crossover_size: 2     # 每次交叉的父代数量
                        # 2: 两两交叉（最常用）
                        # 3: 三方交叉（更多样化）
  
  crossover_n: 10       # 每轮交叉生成的组合数
                        # 越大 → 交叉探索越广
                        # 建议范围: 5-15
  
  parent_selection_strategy: best  # 父代选择策略
                        # best: 优先选择最优轨迹
                        # weighted: 加权采样（鼓励探索）
                        # random: 随机选择
```

#### 执行阶段 (Execution)
```yaml
execution:
  max_loops: 7          # 每条轨迹的最大循环次数
                        # 总步数 = max_loops × 5
  
  steps_per_loop: 5     # 固定为 5（5 步循环）
```

### 7.2 配置示例

**探索模式**（广度优先）:
```yaml
planning:
  num_directions: 15
evolution:
  max_rounds: 3
  crossover_n: 15
  parent_selection_strategy: weighted
```

**深度模式**（深度优先）:
```yaml
planning:
  num_directions: 5
evolution:
  max_rounds: 7
  crossover_n: 5
  parent_selection_strategy: best
```

**平衡模式**（推荐）:
```yaml
planning:
  num_directions: 10
evolution:
  max_rounds: 5
  crossover_n: 10
  parent_selection_strategy: best
```

---

## 8. 数据与回测设置

### 8.1 数据来源

```
数据源: Qlib 中国 A 股数据
路径: /home/tjxy/.qlib/qlib_data/cn_data

包含:
- 日线行情: 开盘价、最高价、最低价、收盘价、成交量
- 市值、估值等基本面数据
- 沪深300 成分股列表
```

### 8.2 市场设置

```yaml
市场: csi300 (沪深300成分股)
基准: SH000300 (沪深300指数)

选择理由:
- 流动性好，交易成本低
- 代表性强，覆盖核心蓝筹
- 数据质量高，异常值少
```

### 8.3 时间划分

```
┌───────────────────────────────────────────────────────────────┐
│                        时间线                                  │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  2016        2020        2021        2022        2025         │
│    │──────────┼───────────┼───────────┼───────────┤          │
│    │  训练集   │  验证集    │         测试集         │          │
│    │  5年     │  1年      │         4年           │          │
│    │          │           │                       │          │
│    │  模型学习  │  调参优化  │    样本外评估（最终）   │          │
│    │  历史规律  │           │                       │          │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

**设计考量**:
- **训练集 (2016-2020)**：5 年数据足够模型学习市场规律
- **验证集 (2021)**：防止过拟合，用于早停和超参调优
- **测试集 (2022-2025)**：完全样本外，评估真实泛化能力

### 8.4 交易策略

```yaml
策略: TopkDropoutStrategy
参数:
  topk: 50      # 持有评分最高的 50 只股票
  n_drop: 5     # 每次调仓剔除评分最低的 5 只

逻辑:
1. 每个交易日，对所有股票计算预测评分
2. 选择评分最高的 50 只构建组合
3. 每次调仓时：
   - 保留原组合中评分仍在 Top50 的股票
   - 卖出评分最低的 5 只
   - 买入新进入 Top50 的股票
4. 等权重持仓

优势:
- 避免过度交易（只剔除最差的）
- 保持组合稳定性
- 降低交易成本
```

---

## 9. 实验结论与分析

### 9.1 实验设计总结

1. **输入**：用户提供探索方向（如"动量策略"、"价值因子"）
2. **过程**：
   - Planning 生成 10 个并行方向
   - 5 轮进化（原始 → 变异 → 交叉 → 变异 → 交叉）
   - 每轮 7 次循环，每次生成 2-3 个因子
3. **输出**：因子库 JSON（包含数百个经过验证的因子）

### 9.2 关键发现

#### 进化阶段对因子质量的影响

| 进化阶段 | 因子特点 | 典型表现 |
|----------|----------|----------|
| Original | 基础探索 | IC 分布广，包含大量噪声因子 |
| Mutation | 改进优化 | 在原始基础上针对性改进，IC 略有提升 |
| Crossover | 组合创新 | 融合多个方向优点，可能产生突破性因子 |

#### 因子筛选策略
- **RankIC 排序**：选择预测能力最强的因子
- **阶段筛选**：不同阶段因子可能有不同特性
- **随机采样**：验证整体因子库质量

### 9.3 实践建议

1. **初次实验**：使用平衡模式配置，运行完整流程
2. **对比基准**：始终与 Alpha158 进行对比
3. **多次验证**：不同时间窗口、不同市场验证
4. **因子筛选**：关注 RankIC > 0.03 且 ICIR > 0.5 的因子

### 9.4 局限性与改进方向

| 局限性 | 可能的改进 |
|--------|-----------|
| LLM 生成因子可能有偏差 | 增加因子正则化约束 |
| 回测可能存在过拟合 | 使用更多样本外验证 |
| 计算资源消耗大 | 优化缓存机制，增量计算 |
| 交易成本简化 | 考虑更真实的滑点模型 |

---

## 附录

### A. 常用命令速查

```bash
# 运行主实验
./运行实验.sh "你的探索方向"

# 独立回测
python backtest_v2/run_backtest.py -c backtest_v2/config.yaml \
    --factor-source custom \
    --factor-json /path/to/factors.json

# 批量回测
./批量回测.sh

# 查看因子库
python show_all_factors.py

# 清理缓存
./清理缓存.sh
```

### B. 目录结构

```
AlphaAgent/                      # Quant Agent Evo 主目录
├── 运行实验.sh                   # 主实验入口
├── 批量回测.sh                   # 批量回测脚本
├── 清理缓存.sh                   # 清理缓存脚本
├── all_factors_library_*.json   # 因子库输出
├── factor_library/              # 因子库采样
├── backtest_v2/                 # 独立回测框架
│   ├── run_backtest.py          # 回测入口
│   ├── config.yaml              # 回测配置
│   └── ...
├── alphaagent/                  # 核心代码
│   ├── app/                     # 应用入口
│   │   └── qlib_rd_loop/        # 主循环
│   │       ├── run_config.yaml
│   │       ├── factor_mining.py
│   │       └── ...
│   ├── components/              # 组件
│   │   ├── workflow/            # 工作流
│   │   │   └── alphaagent_loop.py  # 主循环（含质量门控集成）
│   │   ├── coder/               # 因子编码
│   │   └── proposal/            # 提案生成
│   └── scenarios/               # 场景配置
│       └── qlib/                # Qlib 场景
│           └── regulator/       # 质量管控模块
│               ├── factor_regulator.py      # AST 正则化检验
│               ├── consistency_checker.py   # 一致性检验模块
│               └── consistency_prompts.yaml # 一致性检验提示词
└── /mnt/DATA/quantagent/        # 数据存储
    └── AlphaAgent/
        ├── factor_cache/        # 因子缓存
        ├── backtest_v2_results/ # 回测结果
        └── RD-Agent_workspace/  # 工作空间
```

### C. 指标速查表

| 指标 | 中文名 | 类型 | 好的标准 | 说明 |
|------|--------|------|----------|------|
| IC | 信息系数 | 预测能力 | > 0.05 | 因子与收益的相关性 |
| ICIR | IC信息比 | 预测稳定性 | > 0.5 | IC的稳定程度 |
| Rank IC | 排名IC | 预测能力 | > 0.05 | 排名相关性，更鲁棒 |
| Rank ICIR | 排名IC信息比 | 预测稳定性 | > 0.5 | Rank IC的稳定程度 |
| annualized_return | **超额**年化收益 | 收益 | > 10% | 相对基准的年化超额 |
| information_ratio | 信息比率 | 风险调整收益 | > 1.0 | 超额收益/跟踪误差 |
| max_drawdown | **超额**最大回撤 | 风险 | > -15% | 超额收益曲线最大跌幅 |
| calmar_ratio | 卡尔玛比率 | 风险调整收益 | > 1.0 | 超额年化/\|最大回撤\| |

### D. 参考文献

1. Qlib: An AI-oriented Quantitative Investment Platform (Microsoft Research)
2. LightGBM: A Highly Efficient Gradient Boosting Decision Tree
3. Factor Investing: From Traditional to Alternative Risk Premia

---

*文档版本: 1.3*  
*项目名称: Quant Agent Evo*  
*更新日期: 2026-01-22*
*新增: 因子复杂度和冗余度计算技术详解 (4.7-4.9节)*
